#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
post.py â€“ VayboĞœĞµÑ‚Ñ€ Limassol v6.0  (eveningâ€“tomorrow edition)

Ğ¢Ñ€ĞµĞ±ÑƒĞµĞ¼Ñ‹Ğµ SECRET-Ñ‹ Ğ² GitHub Actions:
OPENAI_API_KEY, TELEGRAM_TOKEN, CHANNEL_ID,
OWM_KEY, AIRVISUAL_KEY, TOMORROW_KEY (Ğ¿Ñ‹Ğ»ÑŒÑ†Ğ°, Ğ¾Ğ¿Ñ†.), COPERNICUS_USER/PASS (Ğ¼Ğ¾Ñ€ÑĞºĞ°Ñ SST).

cron Ğ² workflow: 0 18 * * *  â†’  21:00 Asia/Nicosia.
"""

from __future__ import annotations
import asyncio, os, sys, math, json
from datetime import datetime, timedelta
from typing import Dict, Any, Optional

import requests, swisseph as swe
from openai import OpenAI
from telegram import Bot, error as tg_err

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ¼ĞµÑÑ‚Ğ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HOME = ("Ğ›Ğ¸Ğ¼Ğ°ÑÑĞ¾Ğ»", 34.707, 33.022)
CITIES = {
    "Ğ›Ğ¸Ğ¼Ğ°ÑÑĞ¾Ğ»": (34.707, 33.022),
    "Ğ›Ğ°Ñ€Ğ½Ğ°ĞºĞ°":  (34.916, 33.613),
    "ĞĞ¸ĞºĞ¾ÑĞ¸Ñ":  (35.166, 33.366),
    "ĞŸĞ°Ñ„Ğ¾Ñ":    (34.776, 32.429),
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _get(url: str, **params) -> Optional[dict]:
    try:
        r = requests.get(url, params=params, timeout=20)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        print(f"[warn] {url} â†’ {e}", file=sys.stderr)
        return None


def deg2dir(d: float) -> str:
    dirs = "N NE E SE S SW W NW".split()
    return dirs[int((d + 22.5) % 360 // 45)]


def wind_phrase(kmh: float) -> str:
    return ("ÑˆÑ‚Ğ¸Ğ»ÑŒ" if kmh < 5 else
            "ÑĞ»Ğ°Ğ±Ñ‹Ğ¹" if kmh < 15 else
            "ÑƒĞ¼ĞµÑ€ĞµĞ½Ğ½Ñ‹Ğ¹" if kmh < 30 else
            "ÑĞ¸Ğ»ÑŒĞ½Ñ‹Ğ¹")


clouds_word = lambda pc: "ÑÑĞ½Ğ¾" if pc < 25 else "Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ" if pc < 70 else "Ğ¾Ğ±Ğ»Ğ°Ñ‡Ğ½Ğ¾"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ forecast Ğ´Ğ»Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ‚Ğ¾Ñ‡ĞºĞ¸ (Ğ·Ğ°Ğ²Ñ‚Ñ€Ğ°) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def forecast_tomorrow(lat: float, lon: float) -> dict:
    tomorrow = datetime.utcnow().date() + timedelta(days=1)
    d = _get(
        "https://api.open-meteo.com/v1/forecast",
        latitude=lat,
        longitude=lon,
        timezone="UTC",
        hourly="temperature_2m,weathercode,cloud_cover,surface_pressure",
        daily="temperature_2m_max,temperature_2m_min,temperature_2m_mean,"
              "precipitation_probability_max",
        start_date=tomorrow.isoformat(),
        end_date=(tomorrow + timedelta(days=1)).isoformat(),
    )
    if not d:
        raise RuntimeError("No forecast")
    return d


def fog_risk(codes: list[int]) -> bool:
    return sum(1 for c in codes if c in (45, 48)) / 24 >= 0.40


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ hot / cold Ğ¿Ğ¾ ÑÑ€ĞµĞ´Ğ½ĞµÑÑƒÑ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ¹ TÂ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def hot_cold_mean() -> tuple[str, float, str, float]:
    results = []
    for city, (lat, lon) in CITIES.items():
        try:
            t_mean = forecast_tomorrow(lat, lon)["daily"]["temperature_2m_mean"][0]
            results.append((city, t_mean))
        except Exception:
            continue
    hot = max(results, key=lambda x: x[1])
    cold = min(results, key=lambda x: x[1])
    return hot[0], hot[1], cold[0], cold[1]

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_air() -> Optional[dict]:
    k = os.getenv("AIRVISUAL_KEY")
    if not k:
        return None
    return _get(
        "https://api.airvisual.com/v2/nearest_city",
        lat=HOME[1], lon=HOME[2], key=k)


def pm10_openmeteo() -> Optional[float]:
    d = _get(
        "https://air-quality-api.open-meteo.com/v1/air-quality",
        latitude=HOME[1], longitude=HOME[2],
        hourly="pm10", timezone="UTC")
    try:
        return round(float(d["hourly"]["pm10"][0]), 1)
    except Exception:
        return None


def get_pollen() -> Optional[dict]:
    key = os.getenv("TOMORROW_KEY")
    if not key:
        return None
    d = _get("https://api.tomorrow.io/v4/timelines",
             apikey=key,
             location=f"{HOME[1]},{HOME[2]}",
             fields="treeIndex,grassIndex,weedIndex",
             timesteps="1d")
    try:
        return d["data"]["timelines"][0]["intervals"][0]["values"]
    except Exception:
        return None


def get_sst() -> Optional[float]:
    d = _get(
        "https://marine-api.open-meteo.com/v1/marine",
        latitude=HOME[1], longitude=HOME[2],
        hourly="sea_surface_temperature", timezone="UTC")
    try:
        return round(float(d["hourly"]["sea_surface_temperature"][0]), 1)
    except Exception:
        return None


def get_kp() -> Optional[float]:
    d = _get("https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json")
    try:
        return float(d[-1][1])
    except Exception:
        return None


def get_schumann() -> dict:
    d = _get("https://api.glcoherence.org/v1/earth")
    if d:
        return {"freq": d["frequency_1"], "amp": d["amplitude_1"]}
    d = _get("https://gci-api.ucsd.edu/data/latest")
    if d:
        return {"freq": d["data"]["sr1"]["frequency"], "amp": d["data"]["sr1"]["amplitude"]}
    return {"msg": "Ğ´Ğ°Ñ‚Ñ‡Ğ¸ĞºĞ¸ Ğ¼Ğ¾Ğ»Ñ‡Ğ°Ñ‚ Ñ‚Ñ€ĞµÑ‚Ğ¸Ğ¹ Ğ´ĞµĞ½ÑŒ â€” ÑƒÑˆĞ»Ğ¸ Ğ² Ñ€ĞµÑ‚Ñ€Ğ¸Ñ‚"}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ°ÑÑ‚Ñ€Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SIGNS = ("ĞĞ²Ğ½Ğµ", "Ğ¢ĞµĞ»ÑŒÑ†Ğµ", "Ğ‘Ğ»Ğ¸Ğ·Ğ½ĞµÑ†Ğ°Ñ…", "Ğ Ğ°ĞºĞµ", "Ğ›ÑŒĞ²Ğµ", "Ğ”ĞµĞ²Ğµ",
         "Ğ’ĞµÑĞ°Ñ…", "Ğ¡ĞºĞ¾Ñ€Ğ¿Ğ¸Ğ¾Ğ½Ğµ", "Ğ¡Ñ‚Ñ€ĞµĞ»ÑŒÑ†Ğµ", "ĞšĞ¾Ğ·ĞµÑ€Ğ¾Ğ³Ğµ", "Ğ’Ğ¾Ğ´Ğ¾Ğ»ĞµĞµ", "Ğ Ñ‹Ğ±Ğ°Ñ…")
LUNAR_EFF = ("Ğ¿Ñ€Ğ¸Ğ´Ğ°Ñ‘Ñ‚ ÑĞ¼ĞµĞ»Ğ¾ÑÑ‚Ğ¸", "Ğ·Ğ°ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ Ñ‡ÑƒĞ²ÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ¼Ñ„Ğ¾Ñ€Ñ‚", "Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞ°ĞµÑ‚ ĞºĞ¾Ğ¼Ğ¼ÑƒĞ½Ğ¸ĞºĞ°Ğ±ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ",
             "ÑƒÑĞ¸Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ·Ğ°Ğ±Ğ¾Ñ‚Ñƒ", "Ñ€Ğ°Ğ·Ğ¶Ğ¸Ğ³Ğ°ĞµÑ‚ Ñ‚Ğ²Ğ¾Ñ€Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¾Ğ³Ğ¾Ğ½ÑŒ", "Ğ½Ğ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ½Ğ° Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº",
             "Ğ·Ğ°ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¸ÑĞºĞ°Ñ‚ÑŒ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ", "Ğ¿Ğ¾Ğ´Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ ÑÑ‚Ñ€Ğ°ÑÑ‚ÑŒ", "Ñ‚Ğ¾Ğ»ĞºĞ°ĞµÑ‚ Ğº Ğ¿Ñ€Ğ¸ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ÑĞ¼",
             "Ñ„Ğ¾ĞºÑƒÑĞ¸Ñ€ÑƒĞµÑ‚ Ğ½Ğ° Ğ´ĞµĞ»Ğµ", "Ğ´Ğ°Ñ€Ğ¸Ñ‚ ÑÑ‚Ñ€Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ´ĞµĞ¸", "ÑƒÑĞ¸Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ ÑĞ¼Ğ¿Ğ°Ñ‚Ğ¸Ñ")


def moon_phase(jd):
    sun = swe.calc_ut(jd, swe.SUN)[0][0]
    moon = swe.calc_ut(jd, swe.MOON)[0][0]
    phase = ((moon - sun + 360) % 360) / 360
    illum = round(abs(math.cos(math.pi * phase)) * 100)
    name = ("ĞĞ¾Ğ²Ğ¾Ğ»ÑƒĞ½Ğ¸Ğµ" if illum < 5 else "Ğ Ğ°ÑÑ‚ÑƒÑ‰Ğ°Ñ Ğ›ÑƒĞ½Ğ°" if phase < .5 else
            "ĞŸĞ¾Ğ»Ğ½Ğ¾Ğ»ÑƒĞ½Ğ¸Ğµ" if illum > 95 else "Ğ£Ğ±Ñ‹Ğ²Ğ°ÑÑ‰Ğ°Ñ Ğ›ÑƒĞ½Ğ°")
    sign = int(moon // 30)
    return f"{name} Ğ² {SIGNS[sign]} â€” {LUNAR_EFF[sign]} ({illum} %)"


def planet_parade(jd):
    lons = sorted(swe.calc_ut(jd, b)[0][0] for b in
                  (swe.MERCURY, swe.VENUS, swe.MARS, swe.JUPITER, swe.SATURN))
    best = min((lons[i + 2] - lons[i]) % 360 for i in range(len(lons) - 2))
    return "ĞœĞ¸Ğ½Ğ¸-Ğ¿Ğ°Ñ€Ğ°Ğ´ Ğ¿Ğ»Ğ°Ğ½ĞµÑ‚" if best < 90 else None


def trine_vj(jd):
    v, j = swe.calc_ut(jd, swe.VENUS)[0][0], swe.calc_ut(jd, swe.JUPITER)[0][0]
    return "Ğ¢Ñ€Ğ¸Ğ½ Ğ’ĞµĞ½ĞµÑ€Ñ‹ Ğ¸ Ğ®Ğ¿Ğ¸Ñ‚ĞµÑ€Ğ° â€” Ğ²Ğ¾Ğ»Ğ½Ğ° ÑƒĞ´Ğ°Ñ‡Ğ¸" if abs((v - j + 180) % 360 - 180) < 4 else None


def astro_events():
    jd = swe.julday(*datetime.utcnow().timetuple()[:3])
    parts = [moon_phase(jd)]
    for fn in (planet_parade, trine_vj):
        if (s := fn(jd)):
            parts.append(s)
    if swe.calc_ut(jd, swe.MERCURY)[0][3] < 0:
        parts.append("ĞœĞµÑ€ĞºÑƒÑ€Ğ¸Ğ¹ Ñ€ĞµÑ‚Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ´ĞµĞ½")
    return "\n".join(parts)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ GPT Ğ²Ñ‹Ğ²Ğ¾Ğ´ + ÑĞ¾Ğ²ĞµÑ‚Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def gpt_blurb(culprit: str) -> tuple[str, str]:
    prompt = (f"ĞĞ´Ğ½Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¾Ğ¹: 'Ğ•ÑĞ»Ğ¸ Ğ·Ğ°Ğ²Ñ‚Ñ€Ğ° Ñ‡Ñ‚Ğ¾-Ñ‚Ğ¾ Ğ¿Ğ¾Ğ¹Ğ´Ñ‘Ñ‚ Ğ½Ğµ Ñ‚Ğ°Ğº, Ğ²Ğ¸Ğ½Ğ¸Ñ‚Ğµ {culprit}.' "
              f"Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¸Ğ¹ Ğ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¸Ğ² (â‰¤12 ÑĞ»Ğ¾Ğ²). "
              f"ĞŸĞ¾Ñ‚Ğ¾Ğ¼ Ğ¿ÑƒÑÑ‚Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ° Ğ¸ Ñ€Ğ¾Ğ²Ğ½Ğ¾ 3 Ğ²ĞµÑÑ‘Ğ»Ñ‹Ñ… bullet-ÑĞ¾Ğ²ĞµÑ‚Ğ°, â‰¤12 ÑĞ»Ğ¾Ğ².")
    res = OpenAI(api_key=os.getenv("OPENAI_API_KEY")).chat.completions.create(
        model="gpt-4o-mini",
        temperature=0.6,
        messages=[{"role": "user", "content": prompt}]
    ).choices[0].message.content.strip().splitlines()
    lines = [l.strip() for l in res if l.strip()]
    summary = lines[0]
    tips = "\n".join(f"- {l.lstrip('-â€¢ ').strip()}" for l in lines[1:4])
    return summary, tips


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ÑĞ±Ğ¾Ñ€ĞºĞ° Markdown ----------------------------------------
def build_md() -> str:
    name, lat, lon = HOME
    fc = forecast_tomorrow(lat, lon)
    daily = fc["daily"]
    hourly = fc["hourly"]
    fog = fog_risk(hourly["weathercode"])

    hot_city, hot_t, cold_city, cold_t = hot_cold_mean()

    # Ğ´Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ
    try:
        press_val = round(float(hourly["surface_pressure"][0]))
    except Exception:
        press_val = 1013

    P = [
        "â˜€ï¸ <b>ĞŸĞ¾Ğ³Ğ¾Ğ´Ğ° Ğ·Ğ°Ğ²Ñ‚Ñ€Ğ°</b>",
        f"<b>Ğ¢ĞµĞ¼Ğ¿. Ğ´Ğ½Ñ‘Ğ¼:</b> Ğ´Ğ¾ {daily['temperature_2m_max'][0]:.0f} Â°C",
        f"<b>Ğ¢ĞµĞ¼Ğ¿. Ğ½Ğ¾Ñ‡ÑŒÑ:</b> Ğ¾ĞºĞ¾Ğ»Ğ¾ {daily['temperature_2m_min'][0]:.0f} Â°C",
        f"<b>ĞĞ±Ğ»Ğ°Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ:</b> {clouds_word(hourly['cloud_cover'][0])}",
        "<b>ĞÑĞ°Ğ´ĞºĞ¸:</b> Ğ½Ğµ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‚ÑÑ"
        if daily["precipitation_probability_max"][0] < 20
        else "<b>ĞÑĞ°Ğ´ĞºĞ¸:</b> Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶ĞµĞ½ Ğ´Ğ¾Ğ¶Ğ´ÑŒ",
        f"<b>Ğ”Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ:</b> {press_val} Ğ³ĞŸĞ°",
    ]

    if fog:
        P.append("Ğ’ĞµÑ€Ğ¾ÑÑ‚ĞµĞ½ Ñ‚ÑƒĞ¼Ğ°Ğ½ ğŸŒ«ï¸ Ğ² ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¸Ğµ Ñ‡Ğ°ÑÑ‹")

    P.append(f"Ğ¡Ğ°Ğ¼Ñ‹Ğ¹ Ñ‚Ñ‘Ğ¿Ğ»Ñ‹Ğ¹ Ğ³Ğ¾Ñ€Ğ¾Ğ´: {hot_city} ({hot_t:.1f} Â°C)")
    P.append(f"Ğ¡Ğ°Ğ¼Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ñ…Ğ»Ğ°Ğ´Ğ½Ñ‹Ğ¹ Ğ³Ğ¾Ñ€Ğ¾Ğ´: {cold_city} ({cold_t:.1f} Â°C)")

    # â”€â”€â”€ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ²Ğ¾Ğ·Ğ´ÑƒÑ…Ğ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (air := get_air()):
        pol = air["data"]["current"]["pollution"]
        pm25 = pol.get("p2") or round(pol["aqius"] * 0.25, 1)  # Ğ³Ñ€ÑƒĞ±Ğ°Ñ Ğ¾Ñ†ĞµĞ½ĞºĞ°
        pm10 = pol.get("p1") or pm10_openmeteo() or "Ğ½ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"
        lvl = ("Ñ…Ğ¾Ñ€Ğ¾ÑˆĞ¸Ğ¹" if pol["aqius"] <= 50 else
               "ÑƒĞ¼ĞµÑ€ĞµĞ½Ğ½Ñ‹Ğ¹" if pol["aqius"] <= 100 else
               "Ğ²Ñ€ĞµĞ´Ğ½Ñ‹Ğ¹")
        P += [
            "",
            "ğŸŒ¬ï¸ <b>ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ²Ğ¾Ğ·Ğ´ÑƒÑ…Ğ°</b>",
            f"<b>AQI:</b> {pol['aqius']} | <b>PM2.5:</b> {pm25} Âµg/mÂ³ | <b>PM10:</b> {pm10} Âµg/mÂ³",
            f"Ğ’Ğ¾Ğ·Ğ´ÑƒÑ… {lvl}."
        ]

    # â”€â”€â”€ Ğ¿Ñ‹Ğ»ÑŒÑ†Ğ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (poll := get_pollen()):
        def idx(v): return ["Ğ½ĞµÑ‚", "Ğ½Ğ¸Ğ·Ğº", "ÑƒĞ¼ĞµÑ€ĞµĞ½", "Ğ²Ñ‹ÑĞ¾Ğº", "Ğ¾Ñ‡.Ğ²Ñ‹Ñ", "ÑĞºÑÑ‚Ñ€Ğ¸Ğ¼"][int(round(v))]
        P += [
            "",
            "ğŸŒ¿ <b>ĞŸÑ‹Ğ»ÑŒÑ†Ğ°</b>",
            f"Ğ”ĞµÑ€ĞµĞ²ÑŒÑ â€” {idx(poll['treeIndex'])} | Ğ¢Ñ€Ğ°Ğ²Ñ‹ â€” {idx(poll['grassIndex'])} | "
            f"ĞĞ¼Ğ±Ñ€Ğ¾Ğ·Ğ¸Ñ â€” {idx(poll['weedIndex'])}"
        ]

    # â”€â”€â”€ Ğ³ĞµĞ¾Ğ¼Ğ°Ğ³Ğ½Ğ¸Ñ‚ĞºĞ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    kp = get_kp()
    if kp is not None:
        state = ("Ğ±ÑƒÑ€Ñ (G1)" if kp >= 5 else "ÑĞ¿Ğ¾ĞºĞ¾Ğ¹Ğ½Ñ‹Ğ¹" if kp < 4 else "Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞµĞ½Ğ½Ñ‹Ğ¹")
        P += ["", "ğŸŒŒ <b>Ğ“ĞµĞ¾Ğ¼Ğ°Ğ³Ğ½Ğ¸Ñ‚Ğ½Ğ°Ñ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ</b>",
              f"<b>Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ:</b> {state} (Kp {kp:.1f})"]

    # â”€â”€â”€ Ğ¨ÑƒĞ¼Ğ°Ğ½ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    sch = get_schumann()
    if "freq" in sch:
        P += ["", "ğŸ“ˆ <b>Ğ ĞµĞ·Ğ¾Ğ½Ğ°Ğ½Ñ Ğ¨ÑƒĞ¼Ğ°Ğ½Ğ°</b>",
              f"<b>Ğ§Ğ°ÑÑ‚Ğ¾Ñ‚Ğ°:</b> â‰ˆ{sch['freq']:.1f} Ğ“Ñ† â€¢ Ğ°Ğ¼Ğ¿Ğ»Ğ¸Ñ‚ÑƒĞ´Ğ° ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ğ°"]
    else:
        P += ["", "ğŸ“ˆ <b>Ğ ĞµĞ·Ğ¾Ğ½Ğ°Ğ½Ñ Ğ¨ÑƒĞ¼Ğ°Ğ½Ğ°</b>",
              sch.get("msg", "Ğ½ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…")]

    # â”€â”€â”€ Ñ‚ĞµĞ¼Ğ¿ĞµÑ€Ğ°Ñ‚ÑƒÑ€Ğ° Ğ¼Ğ¾Ñ€Ñ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (sst := get_sst()):
        P += ["", "ğŸŒŠ <b>Ğ¢ĞµĞ¼Ğ¿ĞµÑ€Ğ°Ñ‚ÑƒÑ€Ğ° Ğ²Ğ¾Ğ´Ñ‹ Ğ² Ğ¼Ğ¾Ñ€Ğµ</b>",
              f"<b>Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ:</b> {sst} Â°C"]

    # â”€â”€â”€ Ğ°ÑÑ‚Ñ€Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    astro = astro_events()
    P += ["", "ğŸ”® <b>ĞÑÑ‚Ñ€Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ</b>", astro]

    P.append("---")

    culprit_raw = ("Ğ¼Ğ°Ğ³Ğ½Ğ¸Ñ‚Ğ½Ñ‹Ğµ Ğ±ÑƒÑ€Ğ¸" if kp and kp >= 5 else
                   "Ğ½Ğ¸Ğ·ĞºĞ¾Ğµ Ğ´Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ" if press_val < 1007 else
                   "Ñ‚ÑƒĞ¼Ğ°Ğ½" if fog else
                   "Ğ¼Ğ¸Ğ½Ğ¸-Ğ¿Ğ°Ñ€Ğ°Ğ´ Ğ¿Ğ»Ğ°Ğ½ĞµÑ‚")
    summary, tips = gpt_blurb(culprit_raw)

    P += ["<b>ğŸ“ Ğ’Ñ‹Ğ²Ğ¾Ğ´</b>", summary, "", "<b>âœ… Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸</b>", tips]
    return "\n".join(P)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Telegram send â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def send(text: str):
    await Bot(os.getenv("TELEGRAM_TOKEN")).send_message(
        chat_id=os.getenv("CHANNEL_ID"),
        text=text[:4096],
        parse_mode="HTML",
        disable_web_page_preview=True)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def main():
    md = build_md()
    print("Preview:", md.replace("\n", " | ")[:400])
    try:
        await send(md)
        print("âœ“ sent")
    except tg_err.TelegramError as e:
        print("Telegram error:", e, file=sys.stderr)
        raise


if __name__ == "__main__":
    asyncio.run(main())
